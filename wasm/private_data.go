package wasm

import (
	"bufio"
	"bytes"
	"compress/zlib"
	"io"
	"strconv"

	"github.com/klauspost/compress/zstd"
	"github.com/pdfcpu/pdfcpu/pkg/pdfcpu"
	"github.com/pkg/errors"
)

type PrivateData interface {
	io.Closer
	// Scan advances the Scanner to the next token (line), which will then be available through the Bytes method.
	Scan() bool
	// Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.
	Bytes() []byte
	// Err returns the first non-EOF error that was encountered by the Scanner.
	Err() error
}

var (
	BufferSize = 128 * 1024
)

type closer struct {
	*bufio.Scanner
	zstd *zstd.Decoder
	zlib io.Closer
}

func (cl *closer) Close() error {
	if cl.zstd != nil {
		cl.zstd.Close()
	}
	if cl.zlib != nil {
		cl.zlib.Close()
	}
	return nil
}

// this is _almost_ copy of https://pkg.go.dev/bufio#ScanLines
// but instead looks for \r - in line w/ how private data behaves
func scanLines(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}
	if i := bytes.IndexByte(data, '\r'); i >= 0 {
		// We have a full newline-terminated line.
		return i + 1, data[0:i], nil
	}
	// If we're at EOF, we have a final, non-terminated line. Return it.
	if atEOF {
		return len(data), data, nil
	}
	// Request more data.
	return 0, nil, nil
}

func (dc *decompressor) process() (PrivateData, error) {
	var closer closer
	reader := io.MultiReader(dc.chunks...)
	if len(dc.zstdChunks) > 0 {
		chunk, err := zstd.NewReader(io.MultiReader(dc.zstdChunks...))
		if err != nil {
			return nil, errors.Wrapf(err, "while preparing zstd decoder")
		}
		closer.zstd = chunk
		reader = io.MultiReader(reader, chunk)
	}
	if len(dc.zlibChunks) > 0 {
		chunk, err := zlib.NewReader(io.MultiReader(dc.zlibChunks...))
		if err != nil {
			return nil, errors.Wrapf(err, "while preparing zlib decoder")
		}
		closer.zlib = chunk
		reader = io.MultiReader(reader, chunk)
	}
	scanner := bufio.NewScanner(reader)
	buffer := make([]byte, BufferSize)
	scanner.Buffer(buffer, len(buffer))
	scanner.Split(scanLines)
	closer.Scanner = scanner
	return &closer, nil
}

type decompressor struct {
	chunks     []io.Reader
	zstdChunks []io.Reader
	zlibChunks []io.Reader
}

func (dc *decompressor) addZstd(chunk *zstdChunk) error {
	dc.zstdChunks = append(dc.zstdChunks, bytes.NewBuffer(chunk.compressed[len(chunk.header):]))
	return nil
}

func (dc *decompressor) addZlib(chunk *zlibChunk) error {
	dc.zlibChunks = append(dc.zlibChunks, bytes.NewBuffer(chunk.compressed[len(chunk.header):]))
	return nil
}

func (dc *decompressor) addRaw(bs []byte) error {
	dc.chunks = append(dc.chunks, bytes.NewBuffer(bs))
	return nil
}

type zstdChunk struct {
	compressed []byte
	header     string
}

type zlibChunk struct {
	compressed []byte
	header     string
}

type parsingCtx struct {
	pdf                *pdfcpu.Context
	private            pdfcpu.Dict
	currentCompression int
	dc                 decompressor
}

func (ctx *parsingCtx) emitChunk(key string) error {
	meta := ctx.private[key]
	chunk, _, err := ctx.pdf.DereferenceStreamDict(meta)
	if err != nil {
		return err
	}
	if ctx.currentCompression == compressionZstd {
		return ctx.dc.addZstd(&zstdChunk{chunk.Raw, ""})
	}
	if ctx.currentCompression == compressionZlib {
		return ctx.dc.addZlib(&zlibChunk{chunk.Raw, ""})
	}
	if err = chunk.Decode(); err != nil {
		return errors.Wrap(err, "when decoding chunk")
	}
	if string(chunk.Content[0]) == "%" && string(chunk.Content[:20]) == "%AI24_ZStandard_Data" {
		ctx.currentCompression = compressionZstd
		return ctx.dc.addZstd(&zstdChunk{chunk.Content, string(chunk.Content[:20])})
	}
	if string(chunk.Content[0]) == "%" && string(chunk.Content[:20]) == "%AI12_CompressedData" {
		ctx.currentCompression = compressionZlib
		return ctx.dc.addZlib(&zlibChunk{chunk.Content, string(chunk.Content[:20])})
	}
	return ctx.dc.addRaw(chunk.Content)
}

const (
	compressionNone = iota
	compressionZlib
	compressionZstd
)

func extractPrivateData(ctx *pdfcpu.Context) (PrivateData, error) {
	dict, _, _, err := ctx.PageDict(1, false)
	if err != nil {
		return nil, errors.WithMessage(err, "pageDict(1)")
	}
	ref, ok := dict.DictEntry("PieceInfo")["Illustrator"].(pdfcpu.IndirectRef)
	if !ok {
		return nil, errors.New("PieceInfo->Illustrator is not IndirectRef")
	}
	obj1, err := ctx.DereferenceDict(ref)
	if err != nil {
		return nil, errors.WithMessage(err, "Dereference(PieceInfo->Illustrator) is not Dict")
	}
	obj2, err := ctx.Dereference(obj1.IndirectRefEntry("Private"))
	if err != nil {
		return nil, errors.WithMessage(err, "PieceInfo->Illustrator->Private is not a valid object")
	}
	ref2, ok := obj2.(*pdfcpu.IndirectRef)
	if !ok {
		return nil, errors.New("PieceInfo->Illustrator->Private is not IndirectRef")
	}
	private, err := ctx.DereferenceDict(*ref2) // bug?
	if err != nil {
		return nil, errors.WithMessage(err, "PieceInfo->Illustrator->Private is not Dict")
	}

	pCtx := parsingCtx{
		pdf:     ctx,
		private: private,
		dc:      decompressor{},
	}

	err = pCtx.emitChunk("AIMetaData")
	if err != nil {
		return nil, errors.WithMessage(err, "whilst reading AIMetaData")
	}

	numBlock := private["NumBlock"].(pdfcpu.Integer).Value()
	for i := 1; i <= numBlock; i += 1 {
		key := "AIPrivateData" + strconv.Itoa(i)
		err := pCtx.emitChunk(key)
		if err != nil {
			altKey := "AIPDFPrivateData" + strconv.Itoa(i)
			err := pCtx.emitChunk(altKey)
			if err != nil {
				return nil, errors.WithMessage(err, "whilst reading "+key)
			}
		}
	}

	return pCtx.dc.process()
}
